http://hackage.haskell.org/package/aeson-0.8.0.1

decode = decodeWith jsonEOF fromJSON

decode :: (FromJSON a) => L.ByteString -> Maybe a
decode = decodeWith jsonEOF fromJSON

http://hackage.haskell.org/package/aeson-0.8.0.1/docs/src/Data-Aeson.html#decode

import Data.Aeson.Parser.Internal (decodeWith, decodeStrictWith,
                                   eitherDecodeWith, eitherDecodeStrictWith,
                                   jsonEOF, json, jsonEOF', json')


import qualified Data.Attoparsec.Lazy as L

http://hackage.haskell.org/package/aeson-0.6.0.0/docs/src/Data-Aeson-Parser-Internal.html


decodeWith :: Parser Value -> (Value -> Result a) -> L.ByteString -> Maybe a
decodeWith p to s =
    case L.parse p s of
      L.Done _ v -> case to v of
                      Success a -> Just a
                      _         -> Nothing

import qualified Data.Attoparsec.Lazy as L

https://hackage.haskell.org/package/attoparsec-0.12.1.2

import Data.Attoparsec.ByteString.Lazy

https://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-ByteString-Lazy.html

jsonEOF :: Parser Value
jsonEOF = json <* skipSpace <* endOfInput




sepBy1 :: Alternative f => f a -> f s -> f [a]
sepBy1 p s = scan
    where scan = liftA2 (:) p ((s *> scan) <|> pure [])

scan :: s -> (s -> Char -> Maybe s) -> Parser Text

A stateful scanner. The predicate consumes and transforms a state argument, and each transformed state is passed to successive invocations of the predicate on each character of the input until one returns Nothing or the input ends.

This parser does not fail. It will return an empty string if the predicate returns Nothing on the first character of input.

Note: Because this parser does not fail, do not use it with combinators such as many, because such parsers loop until a failure occurs. Careless use will thus result in an infinite loop.

Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

